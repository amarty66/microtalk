<!DOCTYPE html>
<html lang="fr">
 <head>
  <meta charset="utf-8">
  <meta name="Author" lang="fr" content="alain marty" />
  <meta name="Copyright" content="copyleft, GNU GPL" />
  <title>microtalk</title>
  <style> 
#frame { position:absolute; width:500px; padding:10px; background:#ffe; left:50%; margin-left:-260px; border:1px solid grey; }
#input { width:100%; height:270px; font:normal 0.8em courier; border:0px solid black; box-shadow:0 0 8px black;  }
#infos { text-align:center; font:normal 0.8em courier; }
#output { width:98%; font:normal 1.0em arial; box-shadow:0 0 8px black; background:white; padding:5px; white-space:pre-wrap; }
h1 {font:bold 6em georgia,times; text-align:center; color:white; text-shadow:0 0 8px black;}
a {color:grey; text-decoration:none;}
a:hover {color:red;}
  </style>
  <script src="microtalk.js"></script>
  <script src="nanolisp.js"></script>
 </head>
 <body>
 <!-- body onload="update()" -->
  <div id="frame">
   <h1>{µ•talk}</h1>
   <p><b>microtalk</b> is a fork of <a href="http://epsilonwiki.free.fr/alphawiki_2/index.php?view=foundations">lambdatalk</a> which can be used out of  <a href="http://epsilonwiki.free.fr/alphawiki_2/">alphawiki++</a> via a simple HTML file (see page source). With about 750 lines the <a href="microtalk.js">microtalk.js</a> JS code is reduced to a small dictionary of 112 primitive functions (HTML, maths, booleans, pairs, lists, SVG, ...), to three main special forms [if,lambda,def] and three sugar forms [let,q,'].</p>
   <p><i>Alain Marty | copyleft GPL | updated on 20160215</i></p> 

<!-- start of input, infos, output containers -->
   <textarea id="input" onkeyup="update()"></textarea>
   <div id="infos"></div>
   <div id="output"></div>
<!-- end of input, infos, output containers -->

   <h3>A first set of examples to test.</h3>
   <p>Help can be found in <a href="http://epsilonwiki.free.fr/alphawiki_2/">alphawiki web site</a>.</p>

   <pre style="white-space:pre-wrap">
{lib} -> displays the list of primitives

<h3>1) HTML</h3>
{h1 µ-talk}
{p A few examples of what can be done with {b µ-talk}:}
{ul 
 {li The list of functions: {lib}}
 {li {b Links}, for instance: 
   {a {@ href="http://www.pixar.com/"}PIXAR}.}
 {li Formulas, for instance: 
   √(3{sup 2}+4{sup 2}) = {sqrt {+ {* 3 3} {* 4 4}}}}
 {li Insert {b pictures}, for instance: 
  {img 
   {@ src="data/amelie_poulain.jpg" 
      height="90" 
      title="Amélie Poulain" 
      style="border:1px solid white;
             box-shadow:0 0 8px black;"}}}
 {li And some others alike with HTML tags and CSS rules.}
}

{minibox {@ height="500" width="800" thumb="50"}
   (http://epsilonwiki.free.fr/alphawiki_2/data/microtalk/data/amelie_poulain.jpg Amélie Poulain loves ze lambdaway)
   (http://epsilonwiki.free.fr/alphawiki_2/data/microtalk/data/montgomery_clift.jpg ... but Montgomery Clift has doubts about its relevance)
   (http://epsilonwiki.free.fr/alphawiki_2/data/microtalk/data/ava_gardner.jpg Ava Gardner loves...)
   (http://epsilonwiki.free.fr/alphawiki_2/data/microtalk/data/decasteljau.jpg ... the de Casteljau algorithm)
} 

<h3>2) MATHS</h3>
{pre
  {+ 1 2 3 4 5 6}
  '{+ 1 2 3 4 5 6}
  {q {+ 1 2}}
  {def a 123} 
  {a}
  {{lambda {x} {* x x}} 12}
  {{lambda {:x}
    {let {{:a {+ :x 1}}
          {:b {- :x 1}}}
    {* :a :b}
   }} 3}

  {def fac {lambda {:n}
   {if {< :n 1}
     then 1
     else {* :n {fac {- :n 1}}}}}}
  {fac 16} 

  {def add {lambda {:a :b} {+ :a :b}}}
  {map {add 1} 1 2 3}
  {reduce add 1 2 3}
  {reduce add {map {add 1} {serie 1 10}}}
}

<h3>3) PAIRS and LISTS</h3>
<p>More infos in <a href="http://epsilonwiki.free.fr/alphawiki_2/index.php?view=insertion_sort_2">insertion sort</a>.</p>
{pre
{car {cons aa bb}} 
{cdr {cons aa bb}} 
{cons? {cons aa bb}}
{cons? hello}
{cons.disp {cons aa bb}}
{cons.disp {cons {cons aa bb} 
                 {cons cc dd}}}
{cons.disp {cons {cons {cons a a} {cons b b}} 
                 {cons {cons c c} {cons d d}}}}
{cons.disp {cons {cons {cons a a} b} 
                 {cons c {cons d d}}}} 

{def list.insert {lambda {:x :comp :l}
  {if {equal? :l nil}
   then {cons :x :l}
   else {if {:comp :x {car :l}}
   then {cons :x :l}
   else {cons {car :l} {list.insert :x :comp {cdr :l}}}}}}} 

{def list.sort {lambda {:comp :l}
  {if {equal? :l nil}
   then nil
   else {list.insert {car :l} 
                     :comp {list.sort :comp {cdr :l}}}}}}

1) defining a list of randomized numbers: 
 {def LIST {list.new 99 61 22 64 71 75 7 93 32 63 61 67 93 38 88 26 2 90}}

2) displaying this list: 
 {list.disp {LIST}}  

3) ascending sort of this list: 
 {list.disp {list.sort <  {LIST}}} 

4) descending sort of this list: 
 {list.disp {list.sort > {LIST}}} 

}

<h3>4) CURVES</h3>
<p>More infos in <a href="http://epsilonwiki.free.fr/alphawiki_2/index.php?view=decasteljau5">de casteljau</a>.</p>

{pre

{def castel.interpol {lambda {:p0 :p1 :t}
 {cons {+ {* {car :p0} {- 1 :t}} {* {car :p1} :t}} 
       {+ {* {cdr :p0} {- 1 :t}} {* {cdr :p1} :t}}}}}
{def castel.sub {lambda {:l :t}
 {if {equal? {cdr :l} nil}
  then nil
  else {cons {castel.interpol {car :l} {car {cdr :l}} :t} 
             {castel.sub {cdr :l} :t}}}}}
{def castel.point {lambda {:l :t}
 {if {equal? {cdr :l} nil}
  then {car :l}
  else {castel.point {castel.sub :l :t} :t}}}}
{def castel.build 
 {lambda {:p :t0 :t1 :dt}
  {list.new {map 
   {{lambda {:q} {castel.point :q}} :p} 
    {serie :t0 :t1 :dt}}}}}

{def castel.split 
 {def split_g {lambda {:l :g :t}
  {if {equal? :l nil}
   then :g
   else {cons {car :l} 
              {split_g {castel.sub :l :t} :g :t}} }}}
 {def split_d {lambda {:l :d :t}
  {if {equal? :l nil}
   then :d
   else {cons {list.last :l} 
              {split_d {castel.sub :l :t} :d :t}} }}}
 {lambda {:l :t0 :t1}
  {split_d {split_g :l nil :t1} nil :t0} }}

{def svg.frame {lambda {:w :h}
  svg {@ width=":wpx" height=":hpx" 
         style="border:1px solid #888; box-shadow:0 0 8px;"}}}
{def svg.dot {lambda {:p}
 {circle {@ cx="{car :p}" cy="{cdr :p}" r="5" 
            stroke="black" stroke-width="3"
            fill="rgba(255,0,0,0.5)"}}
}}
{def svg.poly
 {def svg.list2xy {lambda {:l}  
  {if {equal? :l nil}
   then else {car {car :l}} {cdr {car :l}} 
             {svg.list2xy {cdr :l}}}}}
 {lambda {:p :c :w}
  {polyline {@ points="{svg.list2xy :p}" 
    stroke=":c" fill="transparent" stroke-width=":w"
}}}}

{def p0 {cons 80 20}} = {cons.disp {p0}}
{def p1 {cons 480 100}} = {cons.disp {p1}}
{def p2 {cons 60 150}} = {cons.disp {p2}}
{def p3 {cons 400 190}} = {cons.disp {p3}}
{def p4 {cons 480 30}} = {cons.disp {p4}}
{def p5 {cons 160 150}} = {cons.disp {p5}}
{def L6  {list.new {p0} {p1} {p2} {p3} {p4} {p5}}}
{def sL6 {castel.split {L6} 0.25 0.75}}
}

{{svg.frame 490 200}  
 {svg.dot {p0}}
 {svg.dot {p1}}
 {svg.dot {p2}}
 {svg.dot {p3}}
 {svg.dot {p4}}
 {svg.dot {p5}}
 {svg.poly {L6} grey 1}          
 {svg.poly {castel.build {L6} -0.025 1.05 0.02} black 2}
 {svg.poly {sL6} grey 1}
 {svg.poly {castel.build {sL6} 0 1 0.05} red 4}
} 

<center><img src="http://epsilonwiki.free.fr/alphawiki_2/data/microtalk/data/decasteljau.jpg" width="100%" /></center>

<h3>5) TURTLE GRAPHICS</h3>
{def koch
 {lambda {:d :e}
  {if {<  :d :e}
   then M:d
   else 
    {koch {/ :d 3} :e} T60
    {koch {/ :d 3} :e} T-120
    {koch {/ :d 3} :e} T60
    {koch {/ :d 3} :e}
}}}
{def tree
 {lambda {:s}
  {if {<  :s 10} then else
    M{/ :s 3}           T30  {tree {/ {* :s 2} 3}} 
    T-30      M{/ :s 6} T-25 {tree {/ :s 2}}     
    T25       M{/ :s 3} T-25 {tree {/ :s 2}}    
    T25       M{/ :s 6} M-:s
}}}
{def fern
 {lambda {:s :f}
  {if {<  :s 3} then else
    M:s         T{* 70 :f}      {fern {/ :s 2} {- 0 :f}} 
    T{* -70 :f} M:s T{* -70 :f} {fern {/ :s 2} :f}
    T{* 70 :f}  T{* 7 :f}       {fern {- :s 1} :f}
    T{* -7 :f}  M{* -2 :s}
}}}

{svg 
 {@ width="488px" height="488px" 
    style="border:1px solid #888"}
 {polyline 
  {@ points="{turtle 50 130 90 {koch 400 50}}"
     fill="transparent" stroke="red" stroke-width="3"}}
 {polyline 
  {@ points="{turtle 450 130 -30 {koch 400 20}}"
     fill="transparent" stroke="green" stroke-width="2"}}
 {polyline 
  {@ points="{turtle 250 {+ 130 {* {/ {sqrt 3} 2} 400}} 210 {koch 400 10}}"
     fill="transparent" stroke="blue"}}
 {polyline 
  {@ points="{turtle 250 450 180 {tree 200}}"
     fill="transparent" stroke="black" stroke-width="2"}}
 {polyline 
  {@ points="{turtle 300 490 150 {fern 25 1}}"
     fill="transparent" stroke="grey"}}
}

<h3>6) INTERACTING WITH USER</h3>
{input 
 {@ id="smart_hello" 
    type = "text" 
    placeholder = "Please, enter your name" 
     onkeyup = "document.getElementById('yourName').innerHTML = 
      'Hello ' + document.getElementById('smart_hello').value + ' !'" }} 
{h1 {@ id="yourName"}}

{div {@ id="time_output" style="color:red;"}time: }
{input 
 {@ type="submit" 
    value="start" 
    onclick="document.chrono = window.setInterval( 
     function() '{
       document.getElementById('time_output').innerHTML = 
         'time: ' + MICROTALK.evaluate('{date}').val 
     }, 1000 );"
}} 
{input 
 {@ type="submit" 
    value="stop" 
    onclick="window.clearInterval( document.chrono)"
}}  

<h3>7) STYLING</h3>
{style
 #frame '{background:cyan url('http://epsilonwiki.free.fr/alphawiki_2/data/microtalk/data/amelie_poulain.jpg') no-repeat 98% 0.1%}
 h1 '{font:bold 4em georgia; color:red;} 
 h3 '{font:bold 2em georgia; color:red;} 
} 

<h3>8) NANOLISP</h3>
{nanolisp 
(def insert (lambda (x comp l) 
 (if (null? l) 
   x 
   (if (comp x (car l)) 
    (cons x l) 
    (cons (car l) (insert x comp (cdr l)))))))
(br)
(def sort (lambda (comp l) 
 (if (null? l) 
  l 
  (insert (car l) comp (sort comp (cdr l))))))
(br)
(def L (list 11920 63383 45232 79767 8326 17619 62489 87487 97416 42487 8594 3134 14615 29748 55994 67625 2556 442 91652 8855 64123 87894 13252 48939 6840 41749 41244 27719 84843 17407 27255 30052 69025 18457 27757 34112 53346 41087 3401 55901 35901 28866 99050 51163 97000 83948 57292 50081 33356 96423))
(disp L)
(br)
(disp (sort lt L))
(br)
(disp (sort gt L))
}
   </pre>
  </div>
 </body>
</html>
